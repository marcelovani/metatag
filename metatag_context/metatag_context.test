<?php
/**
 * @file
 * Functional tests for the Metatag:Context module.
 */

/**
 * This extends the basic Metatag test class to reduce code duplication.
 */
class MetatagContextTest extends MetatagTestHelper {
  /**
   * The getInfo() method provides information about the test.
   * In order for the test to be run, the getInfo() method needs
   * to be implemented.
   */
  public static function getInfo() {
    return array(
      'name' => 'Metatag:Context tests',
      'description' => 'Test basic Metatag:Context functionality.',
      'group' => 'Metatag',
    );
  }

  /**
   * Prepares the testing environment
   */
  public function setUp(array $modules = array()) {
    $modules[] = 'context';
    $modules[] = 'metatag_context';
    parent::setUp($modules);

    // Create user.
    $perms = array(
      'bypass node access',
    );
    $this->adminUser = $this->createAdminUser($perms);
    $this->drupalLogin($this->adminUser);

    // Create a content type, with underscores.
    $type_name = strtolower($this->randomName(8)) . '_test';
    $type = $this->createContentType($type_name, $type_name);
    $this->type = $type->type;

    // Store a valid URL name, with hyphens instead of underscores.
    $this->hyphen_type = str_replace('_', '-', $this->type);
  }

  /**
   * Performs the basic tests.
   */
  public function testMetatagContextBasic() {
    // Create a node and assign meta tags.
    $node_data = array(
      'title' => $this->randomName(8),
      'metatags[und][title][value]' => 'My node title',
      'metatags[und][description][value]' => 'My node description',
      'metatags[und][abstract][value]' => 'My node abstract',
      'metatags[und][keywords][value]' => 'My node keywords',
    );
    $this->drupalPost('node/add/' . $this->hyphen_type, $node_data, t('Save'));

    // Test meta tags on node.
    $metatag_object = $this->createMetatagObject('node/1', 'node_metatags');
    foreach ($node_data as $key => $value) {
      // Extract meta tag type from key.
      if (preg_match("/metatags\[und\]\[(.*)\]\[value\]/", $key, $matches)) {
        $type = $matches[1];
        $metatag_object->{$type} = $value;
      }
    }
    $this->checkMetatags($metatag_object);

    // Create metatag contexts.
    $this->context_name = drupal_strtolower($this->randomName(8));
    // Generate metatags and check content.
    $this->metatag_pages['node'] = $this->createMetatagObject('node/1', 'context_node_metatags');
    $this->metatag_pages['page'] = $this->createMetatagObject('<front>', 'context_frontpage_metatags');
    foreach ($this->metatag_pages as $page) {
      $this->generateMetatag($page);
      $this->editMetatag($page);
      // Check meta tags.
      $this->checkMetatags($page);
    }

    // Edit title and check that it overrides the node title.
    $this->metatag_pages['node']->title = 'New title';
    $this->editMetatag($this->metatag_pages['node']);
    $this->checkMetatags($this->metatag_pages['node']);

    // Check that by clearing values on context, it will fallback to node meta tags.
    $node_metatag = $this->metatag_pages['node'];
    foreach ($node_data as $key => $value) {
      // Extract meta tag type from key.
      if (preg_match("/metatags\[und\]\[(.*)\]\[value\]/", $key, $matches)) {
        $type = $matches[1];
        $this->metatag_pages['node']->{$type} = '';
        $node_metatag->{$type} = $value;
      }
    }
    $this->editMetatag($this->metatag_pages['node']);
    $this->checkMetatags($node_metatag);
  }

  /**
   * Creates a metatag object which can be used for generate and check
   * the metatag_context module behavior.
   *
   * @param $path
   *   Path where generate metatags.
   * @param $identifier
   *   Custom test to identify metatags in source code.
   *
   * @return $metatag_object
   *   Metatag mapping object.
   */
  function createMetatagObject($path, $identifier) {
    $metatag_object = new stdClass();
    $metatag_object->name = $identifier;
    $metatag_object->path = $path;
    $metatag_object->title = "My $identifier title";
    $metatag_object->description = "My $identifier description";
    $metatag_object->abstract = "My $identifier abstract";
    $metatag_object->keywords = "My $identifier keywords";

    return $metatag_object;
  }

  /**
   * Generates metatags by path from a metatag_object instance.
   *
   * @return $metatag_object
   *   Metatag mapping object.
   */
  function generateMetatag($metatag_object) {
    // Verify the "add context" page works.
    $this->drupalGet('admin/config/search/metatags/context');
    $this->assertResponse(200);
    $this->assertText(t('Add a meta tag by path'));

    // Verify the "add context" page works.
    $this->drupalGet('admin/config/search/metatags/context/add');
    $this->assertResponse(200);
    $this->assertText(t('The unique ID for this metatag path context rule. This must contain only lower case letters, numbers and underscores.'));

    // Add new Metatag object for this configuration.
    $values = array(
      'name' => $metatag_object->name,
    );

    $this->drupalPost('admin/config/search/metatags/context/add', $values, t('Add and configure'));
  }

  /**
   * Edits metatags by path from a metatag_object instance.
   *
   * @return $metatag_object
   *   Metatag mapping object.
   */
  function editMetatag($metatag_object) {
    $edit_metatag = array(
      'paths' => $metatag_object->path,
      'metatags[und][title][value]' => $metatag_object->title,
      'metatags[und][description][value]' => $metatag_object->description,
      'metatags[und][abstract][value]' => $metatag_object->abstract,
      'metatags[und][keywords][value]' => $metatag_object->keywords,
    );
    $this->drupalPost('admin/config/search/metatags/context/' . $metatag_object->name, $edit_metatag, t('Save'));
  }

  /**
   * Checks if metatags has been added correctly from a metatag_object instance.
   *
   * @return $metatag_object
   *   Metatag mapping object.
   */
  function checkMetatags($metatag_object) {
    $options = array('description', 'abstract', 'keywords');
    $this->drupalGet($metatag_object->path);
    $this->assertResponse(200, 'Found path: ' . $metatag_object->path);

    foreach ($options as $option) {
      if (isset($metatag_object->{$option})) {
        $xpath = $this->xpath("//meta[@name='" .$option ."']");
        $this->assertEqual($xpath[0]['content'], $metatag_object->{$option}, 'Meta ' . $option . ' = ' . $metatag_object->{$option});
      }
      else {
        $this->assertNoRaw('<meta name="' . $option, $option . ' not found in ' . $metatag_object->path);
      }
    }
    if (isset($metatag_object->title)) {
      $this->assertRaw('<title>' . $metatag_object->title . '</title>', 'Title = ' . $metatag_object->title);
    }
  }
}
