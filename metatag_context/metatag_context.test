<?php
/**
 * @file
 * Functional tests for the Metatag:Context module.
 */

/**
 * This extends the basic Metatag test class to reduce code duplication.
 */
class MetatagContextTest extends MetatagTestHelper {
  /**
   * The getInfo() method provides information about the test.
   * In order for the test to be run, the getInfo() method needs
   * to be implemented.
   */
  public static function getInfo() {
    return array(
      'name' => 'Metatag:Context tests',
      'description' => 'Test basic Metatag:Context functionality.',
      'group' => 'Metatag',
    );
  }

  /**
   * Prepares the testing environment
   */
  public function setUp(array $modules = array()) {
    $modules[] = 'context';
    $modules[] = 'metatag_context';
    parent::setUp($modules);

    // Create user.
    $perms = array(
      'bypass node access',
      'administer taxonomy',
    );

    $this->adminUser = $this->createAdminUser($perms);
    $this->drupalLogin($this->adminUser);

    // Create a content type, with underscores.
    $type_name = strtolower($this->randomName(8)) . '_test';
    $type = $this->createContentType($type_name, $type_name);
    $this->type = $type->type;

    // Store a valid URL name, with hyphens instead of underscores.
    $this->hyphen_type = str_replace('_', '-', $this->type);
  }

  /**
   * Performs the basic tests.
   */
  public function testMetatagContextBasic() {
    // Create term.
    $this->drupalPost('admin/structure/taxonomy/add', array(
      'name' => 'mc_test Vocabulary',
      'machine_name' => 'mc_test_vocabulary'
    ), t('Save'));
    $this->drupalPost('admin/structure/taxonomy/mc_test_vocabulary/add', array(
      'name' => 'mc_test Term'
    ), t('Save'));
    $this->drupalGet('taxonomy/term/1');

    // Create content type node.
    $this->drupalPost('node/add/' . $this->hyphen_type, array('title' => 'mc_test Title'), t('Save'));
    $this->context_name = drupal_strtolower($this->randomName(8));

    // Generate metatags and check content.
    $this->metatag_pages['term'] = $this->createMetatagObject('taxonomy/term/1', 'term_metatags');
    $this->metatag_pages['node'] = $this->createMetatagObject('node/1', 'node_metatags');
    $this->metatag_pages['page'] = $this->createMetatagObject('<front>', 'frontpage_metatags');
    foreach ($this->metatag_pages as $page) {
      $this->generateMetatag($page);
      $this->editMetatag($page);
      $this->checkMetatags($page);
    }

    // Edit metatags and check content.
    $this->metatag_pages['node']->title = '[node:title]';
    $this->metatag_pages['node']->description = '';
    $this->editMetatag($this->metatag_pages['node']);
    $this->metatag_pages['node']->title = 'mc_test Title';
    $this->checkMetatags($this->metatag_pages['node']);

    $this->metatag_pages['term']->title = '[term:name]';
    $this->editMetatag($this->metatag_pages['term']);
    $this->metatag_pages['term']->title = 'mc_test Term';
    $this->checkMetatags($this->metatag_pages['term']);
  }

  /**
   * Creates a metatag object which can be used for generate and check
   * the metatag_context module behavior.
   *
   * @param $path
   *   Path where generate metatags.
   * @param $identifier
   *   Custom test to identify metatags in source code.
   *
   * @return $metatag_object
   *   Metatag mapping object.
   */
  function createMetatagObject($path, $identifier) {
    $metatag_object = new stdClass();
    $metatag_object->name = $identifier;
    $metatag_object->path = $path;
    $metatag_object->title = "My $identifier title";
    $metatag_object->description = "My $identifier description";
    $metatag_object->abstract = "My $identifier abstract";
    $metatag_object->keywords = "My $identifier keywords";

    return $metatag_object;
  }

  /**
   * Generates metatags by path from a metatag_object instance.
   *
   * @return $metatag_object
   *   Metatag mapping object.
   */
  function generateMetatag($metatag_object) {
    // Verify the "add context" page works.
    $this->drupalGet('admin/config/search/metatags/context');
    $this->assertResponse(200);
    $this->assertText(t('Add a meta tag by path'));

    // Verify the "add context" page works.
    $this->drupalGet('admin/config/search/metatags/context/add');
    $this->assertResponse(200);
    $this->assertText(t('The unique ID for this metatag path context rule. This must contain only lower case letters, numbers and underscores.'));

    // Add new Metatag object for this configuration.
    $values = array(
      'name' => $metatag_object->name,
    );

    $this->drupalPost('admin/config/search/metatags/context/add', $values, t('Add and configure'));
  }

  /**
   * Edits metatags by path from a metatag_object instance.
   *
   * @return $metatag_object
   *   Metatag mapping object.
   */
  function editMetatag($metatag_object) {
    $edit_metatag = array(
      'paths' => $metatag_object->path,
      'metatags[und][title][value]' => $metatag_object->title,
      'metatags[und][description][value]' => $metatag_object->description,
      'metatags[und][abstract][value]' => $metatag_object->abstract,
      'metatags[und][keywords][value]' => $metatag_object->keywords,
    );
    $this->drupalPost('admin/config/search/metatags/context/' . $metatag_object->name, $edit_metatag, t('Save'));
  }

  /**
   * Checks if metatags has been added correctly from a metatag_object instance.
   *
   * @return $metatag_object
   *   Metatag mapping object.
   */
  function checkMetatags($metatag_object) {
    $options = array('description', 'abstract', 'keywords');
    $this->drupalGet($metatag_object->path);

    foreach ($options as $option) {
      if (!empty($metatag_object->{$option})) {
        $this->assertRaw($metatag_object->{$option}, $option . ' found in ' . $metatag_object->path);
      }
      else {
        $this->assertNoRaw('<meta name="' . $option, $option . ' not found in ' . $metatag_object->path);
      }
    }
    if (!empty($metatag_object->title)) {
      $this->assertRaw($metatag_object->title, 'Title found in ' . $metatag_object->path);
    }
  }
}
